import { addDays, eachDayOfInterval, isSameDay } from 'date-fns';
import React from 'react';

import { getLastAvailableDay } from '@/helpers/getLastAvailableDay';
import { overlapsRange } from '@/helpers/overlapsRange';
import { parseStringToDate } from '@/helpers/parseDate';
import { rangeToString } from '@/helpers/rangeToString';
import { DateOrRange, DateRange } from '@/types';

// Custom hook for handling range picker logic
export const useRangePicker = ({
  excludeDates,
  defaultValue,
  forceValidDates,
}: {
  excludeDates?: (string | DateOrRange)[];
  // I'm creating this forceValidDates to enhance the usability of editing a reservation. This shouldn't be necessary in a real scenario, since this possible and locked dates would be generated by the server.
  forceValidDates?: (string | DateOrRange)[];
  defaultValue?: DateRange;
}) => {
  // State for the start and end dates
  const [startDate, setStartDate] = React.useState<Date | undefined>(
    defaultValue?.[0] ? parseStringToDate(defaultValue?.[0]) : undefined,
  );
  const [endDate, setEndDate] = React.useState<Date | undefined>(
    defaultValue?.[1] ? parseStringToDate(defaultValue?.[1]) : undefined,
  );

  // If initial startDate and endDate are overlapping with locked dates, unset them
  React.useEffect(() => {
    if (
      startDate &&
      endDate &&
      overlapsRange(startDate, endDate, lockedDates)
    ) {
      setStartDate(undefined);
      setEndDate(undefined);
    }
  }, []);

  // Memoized array of locked dates based on excludeDates
  const lockedDates = React.useMemo(() => {
    if (!Array.isArray(excludeDates)) return [];

    const forcedValidDays: Date[] = [];

    forceValidDates?.forEach((dateOrRange: any) => {
      if (Array.isArray(dateOrRange)) {
        if (dateOrRange[0] && dateOrRange[1]) {
          // Parse the dates to ensure they are Date objects
          const startDate = parseStringToDate(dateOrRange[0]);
          const endDate = parseStringToDate(dateOrRange[1]);

          if (startDate && endDate) {
            eachDayOfInterval({
              start: startDate,
              end: endDate,
            }).forEach((validDate) => forcedValidDays.push(validDate));
          }
        }
      } else {
        const parsedDate = parseStringToDate(dateOrRange);
        if (parsedDate) {
          forcedValidDays.push(parsedDate);
        }
      }
    });

    const invalidDates = excludeDates.reduce((accum: Date[], dateOrRange) => {
      const validDates: Date[] = [];

      if (Array.isArray(dateOrRange)) {
        // If dateOrRange is an array, it represents a range of dates
        const dateIntervals = dateOrRange.map((date) =>
          parseStringToDate(date),
        );

        // Add all dates within the interval to validDates
        if (dateIntervals[0] && dateIntervals[1]) {
          eachDayOfInterval({
            start: dateIntervals[0],
            end: dateIntervals[1],
          }).forEach((validDate) => validDates.push(validDate));
        }
      } else {
        // If dateOrRange is a single date, add it to validDates
        const parsedDate = parseStringToDate(dateOrRange);
        parsedDate && validDates.push(parsedDate);
      }

      // Accumulate all valid dates
      return validDates.length ? [...accum, ...validDates] : accum;
    }, []);

    return invalidDates.filter(
      (invalidDate) =>
        !forcedValidDays.some((validDate) => isSameDay(invalidDate, validDate)),
    );
  }, [excludeDates, forceValidDates]);

  // Callback function for handling date range changes
  const onChange = React.useCallback(
    (dates: [Date | null, Date | null]) => {
      const [start, end] = dates;

      let validEnd: Date | null = end;
      let validStart: Date | null = start;

      if (start && end) {
        // Check if the selected range overlaps with any locked dates
        const isOverlapping = overlapsRange(start, end, lockedDates);

        if (isOverlapping) {
          // Adjust the end date to the last available day before overlapping
          validEnd = getLastAvailableDay(start, lockedDates);
          if (!validEnd) {
            validStart = null;
          }
        }
      }

      // Update state with valid start and end dates
      setStartDate(validStart || undefined);
      setEndDate(validEnd || undefined);
    },
    [lockedDates],
  );

  // Function to handle onClose event, adjusting the end date if necessary
  const onClose = () => {
    if (startDate && !endDate) {
      onChange([startDate, addDays(startDate, 1)]);
    }
  };

  // Function to convert start and end dates to string format
  const toString = () => {
    if (startDate) {
      return rangeToString(startDate, endDate);
    }
    return '';
  };

  // Return state and functions for external use
  return { startDate, endDate, toString, onChange, onClose, lockedDates };
};
